= Annotations providing explanations

In order to provide user-friendly reasoning about "why" a validation did not succeed, it is necessary to allow
authors of patterns to provide additional information, explaining what a pattern validates.

Additionally, this RFC defines a common (reusable) extension mechanism, to provide addition information to types
(aka annotations).

Bonus points, if this RFC can also define a way to provide "suggestions" (or warnings), which might still let
a pattern validation succeed, but return additional information that might be useful to the user.

== Motivation

Right now, it is possible to author pretty powerful and complex patterns. However, the outcome of those is either
a boolean (ok, not ok) or a complex three of reasoning. Neither of them is suitable for a user to understand "why" a
validation failed, and what needs to be done in order to remedy it.

== Design

=== Annotation syntax

In order to add additional metadata, like the explanation, to the patterns, some kind of "annotation" is proposed. It
is proposed to use https://doc.rust-lang.org/reference/attributes.html[Rust like attributes], which are actually based
on C# attributes.

NOTE: "Rust like" doesn't mean that they support the full feature set of Rust annotations, or C# annotations. Ideally,
they are a subset of Rust annotations.

=== Functions

Built-in functions should be able to contribute the same information, just using built in code. They might be
able to also craft dynamic messages, based on their input. (e.g. `Dependency 'foo bar' is vulnerable to 'SOME ID'`).

=== Severities

The following severities are defined (in the order of importance, highest first):

error:: Evaluation is failed.
warning:: Evaluation is succeeded. However, there is a condition the user should be aware of.
advice:: Evaluation is succeeded. Additionally, the system has some information the user might benefit from. This can be omitted.
info:: Explanation in the case of a successful validation. This can be omitted.
debug:: Additional debug information. This should be omitted by default.

=== Definition

Annotations can be placed:

* On the definition of a pattern
* On the definition of a field

NOTE: There are more possible locations. Let's start with these and expand later on.

Patterns are evaluated depth-first. The outcome of leave nodes can be zero or more "reasons", each having a severity
attached. The outcome severity is the highest of them.

For aggregating branch elements, the element fails with the highest severity of its children.

.Example of a List with a failed child
[example]
====

Having a list with two annotations:

* error: "List failed"
* advice: "Might be better"

Having a list with the following outcomes:

[source,yaml]
----
- errors: ["Type does not match"]
- warnings: ["Looks fishy"]
- advice: ["Beware"]
- {} # <1>
----
<1> Meaning "successful"

The list element would resolve in:

[source,yaml]
----
- errors: ["List failed"]
  reasons:
    - errors: ["Type does not match"]
    - warnings: ["Looks fishy"]
    - advice: ["Beware"]
    - {}
----
====

.Example of a list with a warning element
[example]
====

Assume the example from before. If the list had:

[source,yaml]
----
- warnings: ["Looks fishy"]
- {}
----

The outcome would instead be:

[source,yaml]
----
- warnings: [ "Not all the list elements validated successfully" ] # <1>
  reasons:
    - warnings: ["Looks fishy"]
    - {}
----
<1> Because this is the standard message for lists

====

.Similar example with only advices
[example]
====

[source,yaml]
----
- advice: ["Beware"]
- {}
----

[source,yaml]
----
- advice: [ "Might be better" ]
  reasons:
    - advice: ["Beware"]
    - {}
----

====

== Examples

=== Plain explanation

Definition:

[source]
----
#[explain("Not a valid dog")]
pattern dog = {
    name: string,
    #[explain("Your dog needs to be trained")]
    trained: true
}
----

Input:
[source,yaml]
----
name: goodboy
trained: false
----

Expected output:

[source,yaml]
----
name: example::dog
explanation:
  error:
    - "Not a valid dog" # overridden from "because not all fields were satisfied"
rationale:
  - name: name
    rationale:
      - name: string
  - name: trained
    explanation:
      error:
        - "Your dog needs to be trained
    rationale:
      - {} # missing name, as it's inline
----

=== Nesting stuff

[source]
----
pattern valid = either || or

#[explain("Is not of type: either")]
pattern either = {
  type: "either"
}

#[explain("Is not of type: or")]
pattern or = {
  type: "or"
}
----

[source,yaml]
----
type: other
----

[source,yaml]
----
name: lang::or
explanation:
  error:
    - "because one of the conditions failed" # currently "" (empty)
rationale:
  - name: example::either
    explanation:
      error:
        - "Is not of type: either" # overridden from "because not all fields were satisfied"
    rationale:
      - name: type
        explanation:
          - error: "" # currently "" (empty)
  - name: example::or
    explanation:
      error:
        - "Is not of type: or" # overridden from "because not all fields were satisfied"
    rationale:
      - name: type
        explanation:
          - error: "" # currently "" (empty)
----

=== Adding a warning

Definition:

[source]
----
#[explain("Not a valid dog")]
pattern dog = {
    name: string,
    #[explain("Make a statement on the training of your dog")]
    trained: is_trained <1>
}

#[info("Well done")]
#[warning("Oh boy")]
pattern is_trained = true
----
<1> As we can only annotate pattern definitions or fields, we need to explicitly declare this as a pattern

Input:

[source,yaml]
----
name: goodboy
trained: false
----

Expected output:

[source,yaml]
----
name: example::dog
explanation:
  error:
    - "Not a valid dog" # overridden from "because not all fields were satisfied"
rationale:
  - name: name
    rationale:
      - name: string
  - name: trained
    explanation:
      error:
        - "Your dog needs to be trained"
    rationale:
      - name: lang::or
        rationale:
          - name: example::is_trained
          - name: example::is_not_trained
----

== Non-goals

=== Dynamic messages through annotations

As a first step, the idea is to use static messages in the annotations. Further on, it might be possible to
come up with some formatting syntax, allowing to dynamically generate (format) as message using "input" values in
the process.

== Implementation

Some thought on the actual implementation:

* We currently have the `reason` and `satisfied` field. It feels like we just need to replace them with the
  `explanation` field (which might be a bad name then). By default, we fill it with the value of the `reason` field,
  but then override it with the "explanation".

=== Corner case: Multiple annotations

Assuming there are multiple annotations on an element present, even with different severities.

In this case, they will simply all be applied.

== Alternatives

=== Only one per level

The proposal is to allow a list of explanations per severity. An alternative would be to just use a single one.

However, it might actually be that some checks have multiple explanations for a failed check. Most likely, as part of
built-in functions.

In cases like this, the alternative would be to concat strings. However, that will drop the information that the
original cause was actually due to multiple (different) reasons.

=== Severities/Priorities

The idea is to use a limited set of severities: `error`, `warning`, `advice`, `info`, `debug`. And by default, any occurrence
of `error` failing the validation. Making it possible to also fail with any `error` or `warning` (or others). But
defining an order (as listed above).

An alternative could be, to just use a numeric value instead. That might give more flexibility, but also create
more confusion (uncertainty) on what the meaning of a value is. And as patterns could come from different authors,
all those authors would need to align on their values.

Therefore, it seems better to use a pre-defined list of severities, which already have a meaning assigned.

=== Dropping `reason` and `satisfied`

Currently, we have two fields which indicate the outcome: `reason` and `satisfied`. We might drop them.

The implication would be, that the `explanation` field (which might be a bad name) is the only carrier of the
information if something was satisfied or not.

Dropping the `reason` field seems to make sense, as the new structure provides more information, and having the `reason`
field in addition feels redundant.

The `satisfied` field can actually also be redundant. It is an aggregation of the `explanation` entries, which the
application can also do for you. So serializing the aggregated information may be convenient, but unnecessary.

Assuming the only way to carry the `satisfied` information is via the `explanation` structure, this would ensure that
every step also provides a reason for the decision, instead of currently just having `""` in many cases. This forces
us to provide meaningful output for the user.

On the other side, this can become rather verbose, and not always required. So providing a pre-aggregate serialization
might be helpful. Still, that could be derived automatically from the generated outcome. And instead of `satisfied`,
this should carry the most important severity. `info` being the default if none or only debug explanations had been
present.